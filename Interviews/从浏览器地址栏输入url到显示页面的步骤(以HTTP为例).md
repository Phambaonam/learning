# 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)  




https://github.com/qiu-deqing/FE-interview




在浏览器地址栏输入URL
浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
如果资源未缓存，发起新请求
如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：
HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
浏览器解析URL获取协议，主机，端口，path
浏览器组装一个HTTP（GET）请求报文
浏览器获取主机ip地址，过程如下：
浏览器缓存
本机缓存
hosts文件
路由器缓存
ISP DNS缓存
DNS递归查询（可能存在负载均衡导致每次IP不一样）
打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：
客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口
服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
客户端发送ACK=Y+1， Seq=Z
TCP链接建立后发送HTTP请求
服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
服务器将响应报文通过TCP连接发送回浏览器
浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：
主动方发送Fin=1， Ack=Z， Seq= X报文
被动方发送ACK=X+1， Seq=Z报文
被动方发送Fin=1， ACK=X， Seq=Y报文
主动方发送ACK=Y， Seq=X报文
浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
如果资源可缓存，进行缓存
对响应进行解码（例如gzip压缩）
根据资源类型决定如何处理（假设资源为HTML文档）
解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释
构建DOM树：
Tokenizing：根据HTML规范将字符流解析为标记
Lexing：词法分析将标记转换为对象并定义属性和规则
DOM construction：根据HTML标记关系将对象组成DOM树
解析过程中遇到图片、样式表、js文件，启动下载
构建CSSOM树：
Tokenizing：字符流转换为标记流
Node：根据标记创建节点
CSSOM：节点创建CSSOM树
根据DOM树和CSSOM树构建渲染树:
从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none
对每一个可见节点，找到恰当的CSSOM规则并应用
发布可视节点的内容和计算样式
js解析如下：
浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading
HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容
当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素
当文档完成解析，document.readState变成interactive
所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()
浏览器在Document对象上触发DOMContentLoaded事件
此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件
显示页面（HTML解析过程中会逐步显示页面）
























http://blog.csdn.net/libin_1/article/details/50778993




这道题目没有所谓的完全的正确答案，这个题目可以让你在任意的一个点深入下去， 只要你对这个点是熟悉的。以下是一个大概流程：

浏览器向DNS服务器查找输入URL对应的IP地址。
DNS服务器返回网站的IP地址。
浏览器根据IP地址与目标web服务器在80端口上建立TCP连接
浏览器获取请求页面的html代码。
浏览器在显示窗口内渲染HTML。
窗口关闭时，浏览器终止与服务器的连接。
这其中最有趣的是第1步和第2步(域名解析)。我们输入的网址(域名)是IP地址的一个别名， 在一个DNS内，一个域名对应一个IP地址。域名系统(DNS) 的工作就是将域名与它的IP地址对应起来。DNS是分布式的，同时也是具有层级关系的。

一个域名服务器虽然只记录一个小的子网内的主机名和IP地址， 但所有的域名服务器联合起来工作，就能将全网内的域名与它们的IP地址对应起来。 这也就意味着，如果一个域名服务器无法找到某个请求域名所对应的IP地址， 它就会向其它的域名服务器发出请求进行寻找。

web前端性能：
即是web用户在访问一个页面时所要花费的时间总和。即一个完全意义上的用户响应时间，相对于服务器的响应时间而言还会包括更多的内容和影响因素。那么一个web页面的完整请求包括了哪些部分的时间总和就是web前段性能分析和优化所需要了解的基础知识，先了解一下用户从浏览器访问一个url后到页面完全展示所有内容的整个过程吧。
页面的请求过程：
1、浏览器的url请求
2、递归寻找DNS服务器
3、连接目标IP并建立TCP连接
4、向目标服务器发送http请求
5、web服务器接收请求后处理
6、web服务器返回相应的结果【无效、重定向、正确页面等】
7、浏览器接收返回的http内容
================================前端解析分割线===========================================
8、开始解析html文件，当然是自上而下，先是头部，后是body
9、当解析到头部css外部链接时，同步去下载，如果遇到外部js链接也是下载【不过js链接不建议放在头部，因为耽误页面第一展现时间】
10、接着解析body部分，边解析边开始生成对应的DOM树，同时等待css文件下载
11、一旦css文件下载完毕，那么就同步去用已经生成的DOM节点+CSS去生成渲染树
12、渲染树一旦有结构模型了，接着就会同步去计算渲染树节点的布局位置
13、一旦计算出来渲染的坐标后，又同步去开始渲染
14、10-13步进行过程中如果遇到图片则跳过去渲染下面内容，等待图片下载成功后会返回来在渲染原来图片的位置
15、同14步，如果渲染过程中出现js代码调整DOM树机构的情况，也会再次重新来过，从修改DOM那步开始
16、最终所有节点和资源都会渲染完成
=========================================分析结束分割线==============================================
17、渲染完成后开始page的onload事件
18、整个页面load完成

整个过程中会有很多的分别请求，所以TCP连接会很多，并且每一个用完都会自己关了，除非是keep-live类型的可以请求多次才关闭。
第二章 WEB前台的优化规则
一、尽量减少 HTTP 请求
有几种常见的方法能切实减少 HTTP 请求：
1、 合并脚本跟样式文件，如可以把多个 CSS 文件合成一个，把多个 JS 文件合成一个。
2、 CSS Sprites 利用 CSS background 相关元素进行背景图绝对定位,把多个图片合成一个图片。
 
二、使用浏览器缓存
       在用户浏览网站的不同页面时，很多内容是重复的，比如相同的JS、CSS、图片等。如果我们能够建议甚至强制浏览器在本地缓存这些文件，将大大降低页面产生的流量，从而降低页面载入时间。
   根据服务器端的响应header，一个文件对浏览器而言，有几级不同的缓存状态。
   1、服务器端告诉浏览器不要缓存此文件，每次都到服务器上更新文件。
   2、服务器端没有给浏览器任何指示。
   3、在上次传输中，服务器给浏览器发送了Last-Modified或Etag数据，再次浏览时浏览器将提交这些数据到服务器，验证本地版本是否最新的，如果为最新的则服务器返回304代码，告诉浏览器直接使用本地版本，否则下载新版本。一般来说，有且只有静态文件，服务器端才会给出这些数据。
   4、服务器强制要求浏览器缓存文件，并设置了过期时间。在缓存未到期之前，浏览器将直接使用本地缓存文件，不会与服务器端产生任何通信。
       我们要做的是尽量强制浏览器到第四种状态，特别是对于JS、CSS、图片等变动较少的文件。
 
三、使用压缩组件
IE和Firefox浏览器都支持客户端GZIP，传输之前，先使用GZIP压缩再传输给客户端，客户端接收之后由浏览器解压，这样虽然稍微占用了一些服务器和客户端的CPU，但是换来的是更高的带宽利用率。对于纯文本来讲，压缩率是相当可观的。如果每个用户节约50%的带宽，那么租用来的那点带宽就可以服务多一倍的客户，并且缩短了数据的传输时间。
 
四、图片、JS的预载入
预载入图像最简单的方法是在 JavaScript 中实例化一个新 Image() 对象，然后将需要载入的图像的 URL 作为参数传入。
function preLoadImg(url) {
var img = new Image();
img.src = url;
}
可以在登录页面预载入JS和图片
 
五、将脚本放在底部
脚本放在顶部带来的问题，
1、  使用脚本时，对于位于脚本以下的内容，逐步呈现将被阻塞
2、  在下载脚本时会阻塞并行下载
放在底部可能会出现JS错误问题，当脚本没加载进来，用户就触发脚本事件。
要综合考虑情况。
 
六、将样式文件放在页面顶部
如果样式表任在加载，构建呈现树就是一种浪费，样式文件放在页面底部可能会出现两种情况：
1、  白屏
2、  无样式内容的闪烁
 
七、使用外部的JS和CSS
将内联的JS和CSS做成外部的JS、CSS。减少重复下载内联的JS和CSS。
 
八、切分组件到多个域
主要的目的是提高页面组件并行下载能力。但不要跨太多域名，建议采用2个子域名。
 
九、精简JS
可以做到两个级别
1、精简：从代码中移除不必要的字符以减少其大小，
2、混淆：在精简的同时，还会改写代码，函数、变量名被转换成更短的字符串
可以使用ShrinkSafe来精简JS  http://shrinksafe.dojotoolkit.org/
 
十、精简CSS
从代码中移除不必要的字符以减少其大小，
可以使用CSS Compressor http://www.cssdrive.com/index.php/main/csscompressor /
 
十一、       精简图片、Flash
对大图片、Flash，要在效果和大小之间做出平衡。
第三章 程序的优化
第四章 数据库的优化
附录A 页面请求分析
  从输入URL到页面呈现需要下面5个步骤
1． 输入URL地址或者点击URL的一个链接
　2． 浏览器根据URL地址，结合DNS，解析出URL对应的IP地址
　3． 发送HTTP请求
　4． 开始连接请求的服务器并且请求相关的内容
　5． 浏览器解析从服务器端返回的内容，并且把页面显现出来
 
上面基本上就是一个页面从请求到实现的基本过程，下面我们将剖析这个过程。
 
当输入URL之后，浏览器就要知道这个URL对应的IP是什么，只有知道了IP地址，浏览器才能准备的把请求发送到指定的服务器的具体IP和端口号上面。浏览器的DNS解析器负责把URL解析为正确的IP地址。这个解析的工作是要花时间的，而且这个解析的时间段内，浏览器不是能从服务器那里下载到任何的东西的。浏览器和操纵系统提供了DNS解析缓存支持。
 
当获得了IP地址之后，那么浏览器就向服务器发送HTTP的请求，过程如下：
1．浏览器通过发送一个TCP的包，要求服务器打开连接
2．服务器也通过发送一个包来应答客户端的浏览器，告诉浏览器连接开了。
3．浏览器发送一个HTTP的GET请求，这个请求包含了很多的东西了，例如我们常见的cookie和其他的head头信息。
这样，一个请求就算是发过去了。
 
请求发送去之后，之后就是服务器的事情了，服务器端的程序把最后的结果发送到客户端。
  其实首先到达浏览器的就是html的那些文档，所谓的html的文档，就是纯粹的html代码，不包含什么图片，脚本，CSS等的。也就是页面的html结构。因为此时返回的只是页面的html结构。这个html文档的发送到浏览器的时间是很短的，一般是占整个响应时间的10%左右。
  这样之后，那么页面的基本的骨架就在浏览器中了，下一步就是浏览器解析页面的过程，也就是一步步从上到下的解析html的骨架了。
如果此时在html文档中，遇到了img标签，那么浏览器就会发送HTTP请求到这个img响应的URL地址去获取图片，然后呈现出来。如果在html文档中有很多的图片，flash，那么浏览器就会一个个的请求，然后呈现，如果每个图片都要请求，那么就要进行之前说的那些步骤：解析url，打开tcp连接等等。打开连接也是要消耗资源的，就像我们在进行数据库访问一样，我们也是尽可能的少开数据库连接，多用连接池中的连接。道理一样，tcp连接也是可以重用的。http1.1提出了持久连接（persistent connection）的概念，也就是说同一条 HTTP 连接，可以同时处理多个请求，减少tcp连接。
当页面的html骨架载入了之后,浏览器就开始解析页面中标签,从上到下开始解析。
首先是head标签的解析，如果发现在head中有要引用的JS脚本，那么浏览器此时就开始请求脚本，此时整个页面的解析过程就停了下来，一直到JS请求完毕。之后页面接着向下解析，如解析body标签，如果在body中有img标签，那么浏览器就会请求img的src对应的资源，如果有多个img标签，那么浏览器就一个个的解析，解析不会像JS那样等待的，会并发的下载。


综上所述：
一个页面的请求等于一个或多个url的请求，因此一个页面里包含的外部请求数会影响页面的整体性能
【每请求一次就要多占用一次cpu使用、多一次tcp连接】
每个url的请求又包括寻址、连接、请求传输、返回传输、断连的过程；因此每个阶段的外部环境也会影响整体性能
【DNS服务器的寻址时间，请求和返回内容时的网络环境】
除了URL请求数量外，每个请求的内容大小也是影响性能的主要因素
【文件越大消耗在传输过程中的时间就越长】
请求同样多的资源，并行请求和串行请求速率是不一样的，所以请求的资源要尽量支持同步请求
【同步请求不同资源，即请求被发送到不同的资源服务器即可】
依据浏览器的加载、渲染机制，选择合适的HTML内容排版方式
【减少反复创建对象实例的次数、充分利用缓存机制】
优先加载用户关注的内容
【css加载优于js内容，首屏内容优于非首屏内容】


关注完http请求的过程后，再来关注整个请求过程中关注的几个时间点，通过确定时间点就可以确定影响性能的时间段，就是确定影响性能的因素。根据上面的介绍主要的几个时间点又可以分页面的整体时间点、以及单个url请求过程中的时间点。【基于httpanalyzer工具的指标】

单个url请求的主要时间点：
1、Cache Read：缓存读取时间，或304错误的处理时间 
2、Block：请求等待时间，取决于缓存检查，网络连接等待
3、DNS Lookup：DNS服务器查找时间，取决于dns服务的数量，dns注册的域
4、Connect：tcp连接的总时间，取决于连接类型，ssh，keepalive都会比http长
5、Send first to last：发送请求内容的时间，取决于请求内容大小，及上行的传输速度
6、Wait：等待响应的时间，取决于网络环境的响应，web服务器的处理时间
7、Receive first to last：接收响应内容的时间，取决于响应内容，下行的传输速度，也要考虑服务器的带宽
8、Time to first byte：从请求一直到接收到第一个字符的总时间，等于1+2+3+4+5+6
9、Network：网络消耗时间，等于3+4
10、Begin to end：整个请求的总时间，等于1+2+3+4+5+6+7


单个页面的主要时间点：
1、DOM Ready Time: DOM完成的时间，从接收html到完全转换成dom树所需的时间
2、DOM Ready to Page Load: 页面元素的加载和渲染完成时间，包括html，css，img及其它内容
3、Page Load Time: page页onload事件的时间，其实际时间等于总时间 - （DOM ready + 元素渲染时间）
4、URL Requests Begin to End:url请求所消耗的所有时间，从发送请求发起到接收最后一个字节断开
5、Network Time:消耗在网络上的时间，即tcp的连接时间
6、Begin to End:所有消耗的时间，包括请求结束后的渲染时间
1.浏览器获得url对应的请求，向操作系统请求该url对应的iP地址
2.操作系统查询DNS （首先查询本地host文件，没有则查询网络）获得对应ip地址
3.浏览器发送tcp连接请求向 ip地址对应的服务器（带SYN标志数据包）。
4.服务器收到tcp连接请求后，回复可以链接请求（有SYN/ACK标志的数据包）。
5.浏览器收到回传的数据，确认ok后，还会向服务端发送数据（带ACK标志的数据包）包表示三次握手结束。
6.三次握手成功后，浏览器和服务端开始tcp连接形式传输数据包。
7.服务器传给浏览所需要的资源数据。
8.浏览器获得数据，渲染网页然后呈现给用户。






chrome://net-internals/#dns


https://segmentfault.com/a/1190000003696655






5，http三次握手。
6，tcp/ip建立起来，浏览器就可以向服务器发送http请求，使用了get方法请求了一个根域里面的一个域名...
7,服务器端接收了这个请求，根据路径参数，经过后端的一些处理之后，把处理后的结果的数据返回给浏览器，如果是某个网站的页面，就直接返回页面。
8.浏览器拿到完整的html页面代码，在解析和渲染这个页面的时候，里面的js css图片，静态资源，也同样经过上面的步骤。
9.浏览器根据拿到的资源，对页面进行渲染，最终把完整的页面呈现给用户。

三次握手，四次分手


TCP SYN ACK

三次握手：
握手过程的第一个段的代码位设置为SYN，序列号为x，表示开始一次握手。接收方收到这个段后，向发送者回发一个段。代码位设置为SYN和ACK，序列号设置为y，确认序列号设置为x+1。发送者在受到这个段后，知道就可以进行TCP数据发送了，于是，它又向接收者发送一个ACK段，表示，双方的连接已经建立。
Client --> 置SYN标志 序列号 = J，确认号 = 0 ----> Server
Client <-- 置SYN标志 置ACK标志 序列号 = K, 确认号 = J + 1 <-- Server
Clinet --> 置ACK标志 序列号 = J + 1，确认号 = K + 1 --> Server
a 发起方 b接受方
a发送一个SYN包给b，b回一个[SYN,ACK]给b，a再回一个ACK包给b；

数据交换：
a ---->b
a 发送数据完毕，（PSH,ACK） aseq = x，ack=y，datalen = z
b 接受到以后发送（ACK） bseq = aack， back = aseq + alen， datalen=blen
b 发送数据完毕 （PSH,ACK）bseq = bseq + blen，back = back，datalen = blen
a 确认接受 （ACK） aseq = back ，aack = bseq + blen
注：PSH标志指示接收端应尽快将数据提交给应用层。从我协议分析的经历来看，在数据传输阶段，几乎所有数据包的发送都置了PSH位；而ACK标志位在数据传输阶段也是一直是置位的

在数据传输阶段，按照常理应用层数据的传输是这样的：(我们假定建立连接阶段Client端最后的确认包中序列号 = 55555, 确认号 = 22222)
Client --> 置PSH标志，置ACK标志 序列号 = 55555, 确认号 = 22222，数据包长度 = 11 ---> Server
Client <-- 置ACK标志，序列号 = 22222, 确认号 = 55566 (=55555 + 11)，数据包长度 = 0 <--- Server
Client <-- 置PSH标志，置ACK标志 序列号 = 22223, 确认号 = 55566，数据包长度 = 22 <--- Server
Client --> 置ACK标志，序列号 = 55566, 确认号 = 22244(=22222+22)，数据包长度 = 0 ---> Server
















